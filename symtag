#!/bin/bash

# This program is free software. It comes without any warranty, to the extent
# permitted by applicable law. You can redistribute it and/or modify it under
# the terms of the Do What The Fuck You Want To Public License, Version 2, as
# published by Sam Hocevar. See WTFPL.txt or http://www.wtfpl.net/ for more
# details.

shopt -s expand_aliases
alias fail='{ echo $LINENO; exit 1; }'
alias unpath="sed 's#^.*/##g'"


function main {
  mkdir -p "${SYMTAGDIR}/"{tags,names,hashes} || fail

  add_files
  add_tags
  query
  output_names
  output_tags
}


function add_files {
  for FILE in "${FILES[@]}"; do 
    HASH=not_found
    for HASH_PATH in "${SYMTAGDIR}/hashes/"*; do
      HASH_FILE="$(readlink -m "${HASH_PATH}")" || fail
      if test "${HASH_FILE}" == "$(readlink -e "${FILE}" || fail)"; then
        HASH="$(echo "${HASH_PATH}" | unpath)"
      fi
    done
    if test 'not_found' == "${HASH}"; then
      HASH="$(sha256sum "${FILE}" | {
        read HASH PATH
        echo $HASH
      })" || fail
    fi
    NAME=$(echo "${FILE}" | unpath) || fail
    NAMES+=("${NAME}")
    link_hash_to_file
    link_name_to_hash
  done
}


function link_hash_to_file {
  if ! test -e "${SYMTAGDIR}/hashes/${HASH}"; then
    if test -h "${SYMTAGDIR}/hashes/${HASH}"; then
      rm "${SYMTAGDIR}/hashes/${HASH}" || fail
    fi
    FILE_REL_PATH="$(realpath --relative-to "${SYMTAGDIR}/hashes/" "${FILE}")" || fail
    ln -s "${FILE_REL_PATH}" "${SYMTAGDIR}/hashes/${HASH}" || fail
  fi
}


function link_name_to_hash {
  NAME_PATH="$(readlink -m "${SYMTAGDIR}/names/${NAME}")" || fail
  HASH_PATH="$(readlink -m "${SYMTAGDIR}/hashes/${HASH}")" || fail

  if test -e "${NAME_PATH}"; then
    if ! test "${HASH_PATH}" == "${NAME_PATH}"; then
      rm "${SYMTAGDIR}/names/${NAME}" || fail
    fi
  fi

  if ! test -e "${SYMTAGDIR}/names/${NAME}"; then
    if test -h "${SYMTAGDIR}/names/${NAME}"; then
      rm "${SYMTAGDIR}/names/${NAME}" || fail
    fi
    ln -s "../hashes/${HASH}" "${SYMTAGDIR}/names/${NAME}" || fail
  fi
}


function link_tag_to_hash {
  mkdir -p "${SYMTAGDIR}/tags/${TAG}" || fail
  if test -h "${SYMTAGDIR}/tags/${TAG}/${HASH}"; then
    rm "${SYMTAGDIR}/tags/${TAG}/${HASH}" || fail
  fi
  ln -s "../../hashes/${HASH}" "${SYMTAGDIR}/tags/${TAG}/${HASH}" || fail
}


function add_tags {
  for NAME in "${NAMES[@]}"; do
    HASH="$(readlink "${SYMTAGDIR}/names/${NAME}" | unpath)" || fail
    for TAG in "${TAGS[@]}"; do
      link_tag_to_hash
    done
  done
}


function boolean_or {
  RESULTS+=("${TAGGED_FILES[@]}")
}


function boolean_and {
  NEW_RESULTS=()
  for RESULT in "${RESULTS[@]}"; do
    for TAGGED_FILE in "${TAGGED_FILES[@]}"; do
      if test "${RESULT}" == "${TAGGED_FILE}"; then
        NEW_RESULTS+=("${RESULT}")
      fi
    done
  done
  RESULTS=( "${NEW_RESULTS[@]}" )
}


function boolean_not {
  NEW_RESULTS=()
  for RESULT in "${RESULTS[@]}"; do
    MATCH=no
    for TAGGED_FILE in "${TAGGED_FILES[@]}"; do
      if test "${RESULT}" == "${TAGGED_FILE}"; then
        MATCH=yes
      fi
    done
    if test "${MATCH}" == no; then
      NEW_RESULTS+=( "${RESULT}" )
    fi
  done
  RESULTS=( "${NEW_RESULTS[@]}" )
}


function output_names {

  NULLGLOB=$(shopt nullglob | { read x y && echo $y; })
  shopt -s nullglob || fail
  ALL_NAMES=( "${SYMTAGDIR}/names/"* )
  if test 'off' == "${NULLGLOB}"; then
    shopt -u nullglob || fail
  fi

  i=0
  while test "${i}" -lt "${#ALL_NAMES[@]}"; do
    ALL_NAMES["${i}"]="$( echo "${ALL_NAMES[$i]}" | unpath )"
    i=$(( "${i}" + 1 ))
  done

  for RESULT in "${RESULTS[@]}"; do
    for NAME in "${ALL_NAMES[@]}"; do
      HASH="$(readlink "${SYMTAGDIR}/names/${NAME}" | unpath)"
      if test "${HASH}" == "${RESULT}"; then
        case "${OUTPUT}" in
          hash)
            echo "${HASH}"
            ;;
          file)
            readlink "${SYMTAGDIR}/hashes/${HASH}"
            ;;
          link)
            echo "${SYMTAGDIR}/names/${NAME}"
            ;;
          name)
            echo "${NAME}"
            ;;
          *)
            echo -n "${HASH}:  "
            readlink "${SYMTAGDIR}/hashes/${HASH}"
        esac
      fi
    done
  done
}


function output_tags {
  for TAG in "${FILE_TAGS[@]}"; do
    echo "${TAG}"
  done
}


function query {
  for ELEMENT in $QUERY; do
    case "${ELEMENT}" in
      AND|OR|NOT)
        MODE="${ELEMENT}"
        continue
        ;;
      *)
        TAGGED_FILES=( $(test -d "${SYMTAGDIR}/tags/${ELEMENT}/" && ls "${SYMTAGDIR}/tags/${ELEMENT}/") )
        case "${MODE}" in
          OR)
            boolean_or
            ;;
          AND)
            boolean_and
            ;;
          NOT)
            boolean_not
            ;;
          *)
            fail
            ;;
        esac
        ;;
    esac
  done

  FILE_TAGS=()
  for FILE_TO_DUMP in "${FILES_TO_DUMP[@]}"; do
    FILE_ABS_PATH="$(readlink -e "${FILE_TO_DUMP}")" || fail
    HASH=not_found
    for HASH_PATH in "${SYMTAGDIR}/hashes/"*; do
      HASH_ABS_PATH="$(cd "${SYMTAGDIR}/hashes"; readlink -m "${HASH_PATH}")" || fail
      if test "${HASH_ABS_PATH}" == "${FILE_ABS_PATH}"; then
        HASH="$(echo "${HASH_PATH}" | unpath)"
        for TAG_PATH in "${SYMTAGDIR}/tags/"*; do
          TAG="$(echo "${TAG_PATH}" | unpath)"
          if test -h "${SYMTAGDIR}/tags/${TAG}/${HASH}"; then
            FILE_TAGS+=("${TAG}")
          fi
        done
      fi
    done
  done
}


SYMTAGRC=~/.symtagrc
SYMTAGDIR=~/.symtag
OUTPUT=default

TAGS=()
NAMES=()
RESULTS=()
FILES_TO_DUMP=()

MODE=OR

while test $# -gt 0; do
  case "${1}" in
    -c|--config|--rc)
      SYMTAGRC="${2}"
      shift
      ;;
    -n|--name)
      NAMES+=("${2}")
      ;;
    -t|--tag)
      TAGS+=("${2}")
      shift
      ;;
    -q|--query)
      QUERY="${2}"
      shift
      ;;
    -o|--output)
      O_OUTPUT="${2}"
      shift
      ;;
    -f|--file)
      FILES_TO_DUMP=("${2}")
      shift
      ;;
    -*)
      fail
      ;;
    *)
      if test -e "${1}"; then
        FILES+=("${1}")
      fi
      ;;
  esac
  shift
done

if test -f "${SYMTAGRC}"; then
  . "${SYMTAGRC}" || fail
fi

! test '' == "${O_OUTPUT}" &&
  OUTPUT="${O_OUTPUT}"

main
